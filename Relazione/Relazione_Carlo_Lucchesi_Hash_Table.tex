\documentclass{article}
\usepackage{graphicx} %Package del LaTex utile per importare immagini nei documenti.
\usepackage{caption}
\usepackage{subcaption}
\usepackage{fancyhdr}
\usepackage{imakeidx}
\usepackage{hyperref}
\usepackage{geometry}
\usepackage{float}
\hypersetup{
    colorlinks=true,
    linkcolor=black,
    filecolor=magenta,      
    urlcolor=cyan,
    pdftitle={Overleaf Example},
    pdfpagemode=FullScreen,
    }
\graphicspath{{Immagini/}} %Indica la cartella in cui si trovano le immagini.

\renewcommand{\contentsname}{Indice}

\renewcommand{\listfigurename}{Lista delle Immagini}
\renewcommand{\listtablename}{Lista delle Tabelle}
\renewcommand{\figurename}{Figura}
\renewcommand{\tablename}{Tabella}

\makeindex

\newcommand{\bigO}{\emph{O}}

\newcommand{\image}[3][1]{
	\centering
	\includegraphics[width = #1\textwidth]{#2}
	\caption{#3}
}

\newcommand{\newlineitem}[1]{\item \textbf{#1} \hfill \break}

\thispagestyle{empty}

\newlength{\spacing}
\setlength{\spacing}{\baselineskip}
\begin{document}
%\maketitle
\begin{titlepage}
\newgeometry{top = 2.25 cm}
\centering \Huge{\textsl{Confronto di diverse implementazioni di Hash ad Indirizzamento Aperto}}
\vspace{\spacing}
\hrule
\vspace{\spacing}

\includegraphics[width = \textwidth]{Unifi}
\hrule
\vspace{\spacing}
\huge{Corso di Ingegneria Informatica}
\break
\LARGE{Dipartimento di Ingegneria dell'Informazione}
\vspace{\spacing}
\hrule

\vfill
\raggedright{{\large Autore: Carlo Lucchesi}}
\break
\raggedright{{\large Matricola: 7073136}}
\break
\raggedright{{\large Disciplina: Laboratorio di Algoritmi e Strutture Dati}}
\break
\raggedright{{\large Docente di riferimento: Simone Marinai}}

\end{titlepage}

\newpage

\pagenumbering{Roman}
\tableofcontents

\newpage

\pagenumbering{arabic}
\pagestyle{fancy}
\fancyhead[L]{Carlo Lucchesi}
\fancyhead[C]{}
\fancyhead[R]{\includegraphics[height = 1.5\baselineskip]{Unifi_Logo}}
\fancyfoot[L, C]{}
\fancyfoot[R]{\thepage}

%\addtolength{\headwidth}{\marginparsep}
%\addtolength{\headwidth}{\marginparwidth}
\section{Introduzione}

Con questa relazione si descrivono l'approccio e i risultati sperimentali della prima esercitazione del Laboratorio di Algoritmi proposta. Questa avverrà medante la scrittura in codice \textbf{Python} delle strutture dati, insieme agli algoritmi per il loro utilizzo, richieste.
\subsection{Richiesta dell'Esercizio}

Implementare, in lunguaggio \emph{Python}, una tabella hash con indirizzamento aperto che supporti i seguenti metodi di esplorazione:
\begin{itemize}
\item Eplorazione lineare (con coefficenti naturali $\neq 0$ qualsiasi).
\item Eplorazione quadratica.
\item Esplorazione con hash doppio.
\end{itemize}
Eseguire una serie di esperimenti, che consistono nella misurazione del tempo di esecuzione (sempre mediante l'utilizzo di librerie \emph{Python}) in diversi scenari dei vari metodi implementati, per verificare i risultati teorici appresi durante il corso di \textbf{Algoritmi e Strutture Dati}.
Infine redigere una relazione in cui si confrontano i risultati delle verie implementazioni, accompagnati da un opportuno commento in cui si discutono i risultati ottenuti.

\subsection{Piattaforma di Esecuzione dei Test}

Per poter comprendere effettivamente a pieno i risultati, ed eventualemnte confrontarli con altri, è necessario conoscere la \textbf{Piattaforma Hardware} e \textbf{Software} su cui sono stati eseguiti i test.
\subsubsection{Piattaforma hardware}

La piattaforma hardware utilizzata si tratta di un laptop: questo comporta una ridotta capacità di calcolo rispetto a calcolatori desktop o risorse di calcolo remoto (Ad esempio il \textbf{Cloud Computing}).
Le specifiche hardware di interesse, ovvero quelle che hanno un impatto maggiore sui risultati ottenuti, sono:
\begin{itemize}
\item \textbf{CPU:} ARM A9 con frequenza massima pari a 3,6 GHz.
\item \textbf{Scheda Madre:} AsusTek Computer INC X555BP, chipset AMD.
\item \textbf{RAM:} 8GB DDR4-SDRAM.
\item \textbf{GPU:} RADEON R5 M420 con 2GB di memoria.
\item \textbf{Disco:} HDD da 1TB (Partizionato: l'ambiente software ha a disposizione solo 200 GB circa).
\end{itemize} 
Bisogna tenere in considerazione che durante l'esecuzione dei test il laptop è rimasto alimentato.
\subsubsection{Piattaforma software}

Per quanto riguarda la piattaforma software gli aspetti più importanti da tenere in considerazione sono:
\begin{itemize}
\item \textbf{Linguaggio di Sviluppo:} Il linguaggio utilizzato è il Python, che è stato utilizzato con la versione 3.10.6 del suo inetprete.
\item \textbf{Sistema Operativo:} Il sistema operativo su cui sono stati eseguiti i test è Kubuntu verisone 22.04.
\begin{itemize}
\item \textbf{Ambiente Grafico:} KDE plasma 5.29.7.
\end{itemize}
\item \textbf{IDE:} L'IDE utilizato è \textbf{Visual Studio Code} alla versione 1.76.1.
\end{itemize}
\'E necessario specificare l'IDE utilizzato per lo sviluppo del codice in quanto l'esecuzione dei test è avvenuta mediante la sua interfaccia, e che quindi durante i test l'IDE è rimasto in esecuzione. 
\section{Riferimenti Teorici}

In questa sezione si introducono i concetti teorici riguardanti le strutture dati (e gli algoritmi a loro associati) fondamentali per poter stabilire la coerenza dei risultati pratici con quelli teorici. 
\subsection{Concetto di Stima Asintotica del Costo}

Con concetto di \textbf{Stima Asintotica  del Costo Asintotico} di un algoritmo si intende: \emph{una stima dell'andamento del tempo che l'algoritmo richiede per risolvere il suo \textbf{problema computazionale}. Questa stima è definita da una classe di funzioni (che soddisfano certe proprietà) i cui argomenti sono la dimensione dell'ingresso dell'algoritmo.}
Con il termine \emph{dimensione degli input} si può intendere sia la quantità di informazioni che l'input occupa, sia il numero di elementi che lo compongono. Genericamente si fa riferimento al secondo metodo di calcolo. Per quanto riguarda il nostro contesto l'argomento della nostra stima asintotica di costo è il \emph{fattore di caricamento} (che introdurremo nella sezione \ref{fattore_caricamento}).
\subsection{Tabella Hash}
La \textbf{Tabella Hash} è una struttra dati per l'implementazione dei \emph{Dizionari}. Il dizionario è una struttura dati utilizzata per la rappresentazione degli insiemi (in questo caso senza la presenza di multipli), dove ad ogni elemento dell'insieme è associato ad una chiave univoca che lo identifica nella struttura. Lo scopo di questa struttura dati è quello di offrire inserimento e ricerca molto efficenti (con obbiettivo ideale di costo \bigO(1)) 

La tabella hash è costituida da un vettore di memoria su cui andaranno salvati gli elementi che compongono l'insieme. Per stabilire il punto i cui gli elementi dovrano essere inseriti si usa un funzione particolare chiamata \textbf{funzione Hash}. Questa ha l'effetto di prendere in ingresso l'elemento che deve essere inserito, e da come risultato un indice "\emph{casuale}" (ma deterministico, ovvero a parità di argomento deve sempre generare lo stesso risultato) che indica la posizione in cui inserire l'elemento. Nel nostro contesto, dato che la scelta del tipo di dato è irrilevante, le nostre tabelle hash conterranno numeri interi (in realtà essa tecnicamente conterrà stringhe, ma che per un utilizzatore esterno verranno convertite in numeri interi).

Si noti che la funzione hash generando numeri scorrelati tra di loro potrebbe generare per 2 elementi la stessa chiave; questa eventualità viene chiamata \textbf{collisione}. Queste devono essere opportunamente gestite, e nel nostro caso si utilizzerà la tecnica ad \textbf{Indirizzamento Aperto}, che consiste nel scegliere un succesivo punto di inserimento finchè non si trova una cella libera (oppure si scopre che la tabella è piena). Questa richiederà una modifica della funzione hash che verrà discussa nella sezione \ref{eplorazione}.

\label{fattore_caricamento}
Il parametro che deve essere tenuto in forte considerazione è il \textbf{Fattore di Caricamento} ($\alpha$) che si calcola come \emph{numero di elementi inseriti} (n) diviso \emph{numero di celle disponibili} (m): $\alpha = n / m$.
Questo coefficente indica quanto la tabella è "carica" di elementi, che crescendo ha un impatto negativo su operazioni di accesso.

\subsubsection{Metodi di Esplorazione}
\label{eplorazione}
Come abbiamo detto l'indirizzamento aperto necessita di una modifica della nostra funzione hash, infatti dobbiamo essere capaci di fornire come argomento anche il numero di tenativi falliti, in modo che generi un numero sempre diverso dai precedenti (ma sempre deterministico). Queste versioni modificate di funzioni hash devono generare quella che viene chiamata \textbf{Sequenza di Esplorazione}. L'unico vincolo a questa sequenza è che sia una permutazione di tutte le celle presenti nella tabella. Questo perchè se non fosse così si richierebbe di lasciare vuote delle celle della tabella.

I metodi di esplorazione che andremo a verificare sono i seguenti, generati con le rispettive funzioni:
\begin{itemize}
\item \textbf{Lineare:} \begin{math} h(k, i) = ((k\; mod\; m) + c \cdot i)\; mod\; m\end{math}. \emph{c} può essere qualsiasi numero naturale $\neq 0$.
\item \textbf{Quadratico:} \begin{math} h(k, i) = ((k\; mod\; m) + c_1 \cdot i + c_2 \cdot i ^ 2)\; mod\; m\end{math}. In questo caso $c_1$ e $c_2$ non possono essere numeri qualsiasi. Questi vanno stabiliti secondo dei criteri particolari a seconda della dimensione della tabella (\label{Esplorazione_Quadratica}Wikipedia: \href{https://en.wikipedia.org/wiki/Quadratic_probing}{Quadratic Probing}).
\item \textbf{Doppio:} \begin{math} h(k, i) = ((k\; mod\; m) + ((k\; mod\; m') + 1) \cdot i)\; mod\; m\end{math}. In questo caso $m'$ deve essere un numero minore di $m$ (genericamente $m' = m - 1$). 
\end{itemize}

\subsubsection{Costi Tabella Hash con Indirizzamento Aperto}
Le operazioni principali che si possono eseguire su una tabella hash sono tre: \textbf{Ricerca}, \textbf{Inserimento} e \textbf{Rimozione}.\hfill
\break
Verranno condotti dei test solamente su le prime due operazioni.

La funzione di stima asintotica descritte in seguito derivano da una analisi delle operazioni dell'hash table sotto le seguenti ipotesi: la tabella hash non è piena, non sono avvenute delle cancellazioni, la funzione hash  utilizzata è uniforme (vedi sezione \ref{Hash_Uniforme}). \hfill
\break
Poste queste condizioni si ottengono i seguenti costi asintotici:
\begin{itemize}
\item \textbf{Ricerca con Successo:} \bigO ($\frac{1}{1 - \alpha} $) per gli $\alpha \neq 1$.
\item \textbf{Ricerca con Insuccesso:} \bigO ($\frac{1}{1 - \alpha} $) per gli $\alpha \neq 1$.
\item \textbf{Inserimento:} \bigO ($\frac{1}{\alpha} log(\frac{1}{1 - \alpha})$) per gli $\alpha \neq 0,1$.

\end{itemize}

Per quanto il costo della ricerca con successo ed insuccesso siano uguali da un punto di vista asintotico, questi due casi devono essere trattati separatamente da un punto di vista teorico, e verificheremo in che entità questi due casi differiscono.

\subsection{Hash Uniforme}
\label{Hash_Uniforme}
Con Hash uniforma si intende una funzione hash capace di generare come sequenza di esplorazioni tutte le $m!$ possibili. Questa viene presa come riferimento nei nostri studi teorici (come per esempio la stima asintotica del costo), ma all'atto pratico sono pressochè impossibili da ottenere. Perciò faremo affidamento a funzioni hash meno performati, con il seguente numero di possibili permutazioni generate:
\begin{itemize}
\item \textbf{Esplorazione Lineare:} $m$ possibili permutazioni.
\item \textbf{Esplorazione Quadratica:} $m$ possibili permutazioni.
\item \textbf{Esplorazione con Hash Doppio:} $m^2$ possibili permutazioni.
\end{itemize} 

Vedremo come un numero ridotto di possibili permutazioni generate porti a dei problemi di performance a livello pratico.

\subsection{Clustering}
Con la parola \textbf{Clustering} si intende l'\emph{addensamento} di diversi elemteni su un numero ridotto di celle a disposizione. Questo si viene a creare poichè il numero di sequenze di esplorazione effettivamente generate si discosta sensibilimente dal valore teorico $m!$. Si possono individuare due tipi di clustering.

Il Clustering \emph{Primario} si verifica quando si usa una funzione hash tale per cui, quando generano una sequenza, dal momento in cui generano lo stesso valore allora saranno uguali anche i successivi (fino alla terminazione di una delle due). Quindi in realtà una funzione hash così fatta non fa altro che generare la stessa sequenza, ma traslata di un numero di elementi. La funzione hash con esplorazione lineare è affetta da questo tipo di clustering.

Invece il Clustering \emph{Secondario} si verifica quando una funzione hash tale per cui l'effetto precedentemente descritto si verifica solo quando le due esplorazioni iniziano con lo stesso numero. Ovvero due seguenze si "allineano" solo nel caso in cui inizino dallo stesso valore. La funzione hash con esplorazione quadratica è affetta da questo tipo di clustering.

Dato che il clustering primario si verifica in molti più casi rispetto al secondario, è evidente che in generale l'esplorazione di tipo quadratico sarà migliore di quella lineare. Per quanto riguarda invece l'esplorazione con doppio hash questa non genera nessun tipo di clustering, e quindi può essere considerata (in generale) la migliore delle tre.

\section{Documentazione del Codice}
In questa sezione verrà mostarto parti essenziali del codice utilizzato durante tutti i test
\subsection{Implementazione delle Strutture Dati}
L'implementazione della tabell hash con indirizzamento aperto è stata fatta mediante una classe definita nel file \textbf{Open\_Hash.py} sotto la cartella \textbf{Codice}. Questa è descritta dai seguenti metodi:
\begin{itemize}
\item \textbf{\_\_init\_\_(self, length: int, type: hash\_type, c1: float = 1.0, c2: float = 0.5):}\break \hfill
Questo è il costruttore della tabella hash, quindi si occupa di creare l'array in cui verranno inseriti gli elementi (all'inizio l'array conterrà tutti valori \emph{NIL}). Queste sono le descrizioni del significato degli attributi.
\begin{itemize}
\item \textbf{length: } la lunghezza della tabella hash.
\item \textbf{type: } la tipologia di  esplorazione utilizzare (Lineare, Quaratica o con Doppio Hash).
\item \textbf{c1: } il coefficiente utilizzato nell'esplorazione Lineare o il primo della esplorazione Quadratica.
\item \textbf{c2: } il secondo coefficiente dell'esplorazione Quadratica.
\end{itemize}
\newlineitem{insert(self, x: int):}
Questo è il metodo che permette di inserire l'elemento \textbf{x} all'interno della tabella hash. Questa si occuperà di chiamare la funzione hash in modo consono a come è stata instanziata la tabella hash quando è stata costruita.
\newlineitem{search(self, x: int):}
Questo metodo si occupa di cercare all'interno della tabella il valore \textbf{x}, e di dare come risultato la posizione di dove si trova nell'array se presente, \emph{NIL} altrimenti.
\newlineitem{delete(self, x: int):}
Questa funzione server per eleminare dalla tabella l'elemento \textbf{x} e sostituire al suo posto \emph{DEL}, oppuer se questo non è presente non fare nulla. Questa funzione dà come risultato \emph{True} se l'elemento è stato trovato ed eliminato, \emph{False} altrimenti.
\newlineitem{load\_factor(self):}
Questa funzione da come risultato il \emph{fattore di caricamento} della tabella.

\newlineitem{undo\_element(self, x: int):}
Questo metodo serve per rimuovere l'elemento \textbf{x} dalla tabella hash. Differentemente dal metodo delete questo sostituisce il valore usado la parola \emph{NIL}. Questo metodo può essere usato su un determinato valore solamente se quello è stato l'ultimo ad essere inserito (quello infatti è il significato di undo nella firma del metodo), e che se così non fosse si renderebbe inutilizzabile la tabella hash. Ritorna \emph{True} se l'elemnto viene rimosso, \emph{False} altrimenti.

\newlineitem{\_\_calculate\_hash(self, x: int, i: int):}
Questo metodo privato serve per calcolare \emph{i-esimo} elemento della sequenza di esplorazione dell'elemento \textbf{x}, usando le funzioni hash definite nel costruttore della tabella hash.
\newlineitem{\_\_division\_probing(self, k: int):}
Questo metodo privato calcola il risultato della funzione hash dell'argomento \textbf{k} usando il metodo delle divisioni.
\newlineitem{\_\_linear\_probing(self, k:int , i: int):}
Questo metodo privato calcola il risultato dell'\emph{i-esimo} elemento della sequenza di esplorazione associata al valore \textbf{k} usano il metodo lineare.
\newlineitem{\_\_quadratic\_probing(self, k:int , i: int):}
Questo metodo privato calcola il risultato dell'\emph{i-esimo} elemento della sequenza di esplorazione associata al valore \textbf{k} usano il metodo quadratico.
\newlineitem{\_\_double\_probing(self, k:int , i: int):}
Questo metodo privato calcola il risultato dell'\emph{i-esimo} elemento della sequenza di esplorazione associata al valore \textbf{k} usano il metodo con doppio hash.
\end{itemize}

Il tipo di esplorazione utilizzare sulla tabella hash viene definito nella enumerazione che permette tra solo scelte possibili: Lineare, Quadratico e Doppio.
\subsection{Funzioni di supporto per la Sperimentazione}
Invece, per quanto riguardano le funzioni che sono state utilizate per fare i test, queste si trovano all'interno di 3 file pricipali: \textbf{main.py}, \textbf{Funzioni\_per\_Sperimantazioni.py} e \textbf{Funzioni\_per\_Garfici}.

\subsubsection{main.py}
Dentro il file main.py si trova il codice che serve per poter eseguire tutti i test che sono stati commentati all'interno di questo documento. Questo al fine di rendere più semplice la gestione del software sono stati divisi in funzioni.

\begin{itemize}
\newlineitem{main():}
Questa funzione si occupa di lanciare il programma che esegue i test. Questa richiede in ingresso un numero binario di 4 cifre, dove ogni cifra identifica il test che si vuole fare. Per esmpio impostare la 3° cifra a 1 farà si che il 3° test venga esguito, 0 il contratio. Se l'ingresso dovesse essere più piccolo di 4 cifre il programma si occuperà di aggiugere gli 0 a sinistra per completare il numero. Inserire il numero 0 fa terminare il programma senza eseguire nessun test. L'inseirmento di un numero in un formato diverso oppure troppo grande non verrà accettato e  quindi verrà richiesto di nuovo.
\newlineitem{main\_test(m, iter, interval, verbose, save):}
Questa funzione si occupa di gestire il codice per l'esecuzione dei test test principali, la generazione dei risultati salvati su file \emph{.txt}, la costruzione dei grafici ed ventualmente il loro salvataggio come immagini. I parametri che riceve hanno i seguenti significati
\begin{itemize}
\item \textbf{m:} la dimensione con cui creare le tabelle hash su cui fare i test. Notare che nel caso dell'hash quadratico verrà usata come dimensione il risultato della funzione \emph{closest\_two\_power(m)} .
\item \textbf{iter:} il numero di volte che bisogna eseguire ogni misurazione.
\item \textbf{interval:} ogni quanti elementi bisogna fare una misorazione.
\item \textbf{verbose:} un valore booleano che indica se stampare sullo standard output lo stato dei test o meno.
\item \textbf{save:} un valore booleano che indica se salvare o meno i grafici generati.
\end{itemize}
\newlineitem{test\_linear\_different\_coefficent(m: int, c\_1: int, c\_2: int, iter: int, interval: int, verbose: bool, test: test\_type, suffix: str = "")}
Questa funzione viene utilizzata per eseguire il test di operazioni su una tabella hash ad esplorazione lineare con coefficienti diversi. Questa funzione ha poi il compito di generare dei file \emph{.txt} su cui salverà il risultati. I parametri da fornire hanno il seguente significato.
\begin{itemize}
\item \textbf{m:} la dimensione delle tabelle hash.
\item \textbf{c\_1:} il coefficiente con cui istanziare la prima tabella hash.
\item \textbf{c\_2:} il coefficiente con cui istanziare la seconda tabella hash.
\item \textbf{iter:} quante volte ripetere le misuarzioni.
\item \textbf{interval:} la distanza in numero di elementi tra una misuarzione e l'altra.
\item \textbf{verbose:} un valore booleano che indica se stamapre su standard output lo stato attuale dei test.
\item \textbf{test:} indica il tipo di test da eseguire, che può essere una ricerca con successo, con insuccesso oppure un inserimento.
\item \textbf{suffix:} è una stringa che indica con che suffisso salvare i file \emph{.txt}. Serve per evitare di sovrascrivere dei file che ci potrebbero interessare.
\end{itemize}
\newlineitem{plot\_test\_linear\_different\_coefficent(c\_1: int, c\_2: int,save: bool, test: test\_type, suffix: str = ""):}
Questa funzione serve per disegnare, ed eventualemente salvare i grafici generati da un test con coefficienti di esplorazione lineare diversi. Questi si occpuano di recuperare i dati da file \emph{.txt} opportunamente creati. I parametri hanno il seguente significato.
\begin{itemize}
\item \textbf{c\_1:} il coefficiente con cui era stata istanziata la prima tabella hash.
\item \textbf{c\_2:} il coefficiente con cui era stata istanziata la seconda tabella hash.
\item \textbf{save:} indica se salvare o meno i grafici.
\item \textbf{test:} indica il tipo di test da eseguire, che può essere una ricerca con successo, con insuccesso oppure un inserimento.
\item \textbf{suffix:} è una stringa che indica con che suffisso salvare i file \emph{.txt}. Serve per evitare di sovrascrivere dei file che ci potrebbero interessare.
\end{itemize}

\newlineitem{test\_different\_dimensions(m\_1: int, m\_2: int, iter: int, interval: int, verbose: bool, hash: hash\_type, test: test\_type, suffix: str = ""):}
Questa funzione serve per eseguire i test con tabelle hash di dimensione differente. Questa, una volta fatte le misurazioni, scriverà i risultati su dei file \emph{.txt} opportunamente creati. I parametri hanno i seguenti significati.
\begin{itemize}
\item \textbf{m\_1:} la dimensione con cui istanziare la prima tabella hash.
\item \textbf{m\_2:} la dimensione con cui istanziare la seconda tabella hash.
\item \textbf{iter:} quante volte ripetere le misuarzioni.
\item \textbf{interval:} la distanza in numero di elementi tra una misuarzione e l'altra.
\item \textbf{verbose:} un valore booleano che indica se stamapre su standard output lo stato attuale dei test.
\item \textbf{hash:} il tipo di esplorazione con cui creare le 2 tabelle.
\item \textbf{test:} indica il tipo di test da eseguire, che può essere una ricerca con successo, con insuccesso oppure un inserimento.
\item \textbf{suffix:} è una stringa che indica con che suffisso salvare i file \emph{.txt}. Serve per evitare di sovrascrivere dei file che ci potrebbero interessare.
\end{itemize}
\newlineitem{plot\_test\_different\_dimensions(m\_1: int, m\_2: int, save: bool, hash: hash\_type, test: test\_type, suffix: str = ""):}
Questa funzione serve per generare i grafici di un test eseguito con tabelle hash di misure differenti, ed eventualmente savare il grafico. Quesat recupera i dati da un file \emph{.txt} opportunamente creato. I parametri hanno il seguente significato.
\begin{itemize}
\item \textbf{m\_1:} la dimensione con cui era stata istanziata la prima tabella hash.
\item \textbf{m\_2:} la dimensione con cui era stata istanziata la seconda tabella hash.
\item \textbf{save:} indica se salvare il grafico generato o meno.
\item \textbf{hash:} il tipo di esplorazione con cui creare le 2 tabelle.
\item \textbf{test:} indica il tipo di test da eseguire, che può essere una ricerca con successo, con insuccesso oppure un inserimento.
\item \textbf{suffix:} è una stringa che indica con che suffisso salvare i file \emph{.txt}. Serve per evitare di sovrascrivere dei file che ci potrebbero interessare.
\end{itemize}

\newlineitem{test\_load\_factor(m: int, type: test\_type, iter: int, verbose: bool, suffix: str = ""):}
Questa funzione serve per seguire il test sui fattori di caricamento multipli di 0.1. Questa, una volta ottenuti i risultati, li salva su di un file \emph{.txt}. I parametri hanno il seguente significato.

\begin{itemize}
\item \textbf{m:} la dimensione con creare le tabelle hash.
\item \textbf{type:} il tipo di test da eseguire, che possono essere ricerche con successo, con insuccesso oppure inserimenti.
\item \textbf{iter:} il numero di volte che deve essere eseguita una misurazione.
\item \textbf{verbose:} un valore boleano che indica se mostrare o meno sullo standard output lo stato dei test.
\item \textbf{suffix:} è una stringa che indica con che suffisso salvare i file \emph{.txt}. Serve per evitare di sovrascrivere dei file che ci potrebbero interessare.
\end{itemize}
\end{itemize}
\subsubsection{Funzioni per Sperimentazioni}
In questo file sono presenti le funzioni di supporto per l'esecuzione dei test. Il codice al suo interno è stato suddiviso in funzioni per semplificarne l'utilizzo.
\begin{itemize}
\newlineitem{execute\_test(m: int, m\_q: int, iter: int, interval: int, verbose: bool, type: test\_type, suffix: str = ""):}
Questa funzione serve per eseguire i test di un particolare tipo di operazione su tutti e 3 i tipi di esplorazione. Questa funzione ritorna il tempo totale di esecuzione. I parametri hanno il seguente significato.
\begin{itemize}
\item \textbf{m:} la dimensione con cui creare le tabelle hash con esplorazione lineare ed hash doppio.
\item \textbf{m\_q:} la dimensione con cui creare le tabelle hash con esplorazione quadratica.
\item \textbf{iter:} il numero di volte che deve essere ripetuta una misurazione.
\item \textbf{interval:} la distanza tra una iterazione e l'altra.
\item \textbf{verbose:} indica se mostrare o meno lo stato attuale dei test.
\item \textbf{type:} indica il tipo di test che deve essere eseguito.
\item \textbf{suffix:} indica il suffisso con cui verranno salvati i file dei risultati.
\end{itemize}
Questa funzione non salva i risultati ottenuti, ma chiamando le funzioni search\_experiment o insert\_experiment saranno queste a creare i file \emph{.txt}.
\newlineitem{process\_plots(save: bool, type: test\_type, suffix = ""):}
Questa funzione serve per generare i grafici provenienti da un tipo specifico di test. Quindi recupera dai file \emph{.txt} i risultati e genera i singoli grafici, il grafico a confronto e il grafico a barre. I parametri hanno i seguenti significati.
\begin{itemize}
\item \textbf{save:} indica se salvare o meno i file.
\item \textbf{type:} indica il tipo di operazione a cui appartegono i dati che si vogliono rappresentare.
\item \textbf{suffix:} indica il suffisso che hanno i file che contengono i dati e con il quale eventualemnte salvare i grafici.
\end{itemize} 

\newlineitem{search\_test(hash: open\_hash, type: search\_test\_type, iterations: int = 1, interval:int= 1, verbose: bool = False, percent: float = 10):}
Questa funzione esegue i test della ricerca su una particolare tabella hash. Questa funzione da come valori di ritorno 2 liste: la prima contiene i fattori di caricamento su cui sono state fatte le misurazioni, la seconda il risultati di queste. I parametri hanno questi significati.
\begin{itemize}
\item \textbf{hash:} la tabella hash su cui eseguire il test.
\item \textbf{type:} il tipo di ricerca su cui si vuole fare il test.
\item \textbf{iterations:} il numero di volte che deve essere ripetuta una misurazione.
\item \textbf{interval:} la distanza tra una iterazione e l'altra.
\item \textbf{verbose:} indica se mostrare o meno lo stato attuale dei test.
\item \textbf{percent:} indica ogni quanto in percentuale aggiornare lo stato dei test.
\end{itemize}

\newlineitem{insert\_test(hash: open\_hash, iterations: int = 1, interval:int = 1, verbose: bool = False, percent: float = 10):}
Questa funzione esegue i test di inserimento su una particolare tabella hash. Questa funzione da come valori di ritorno 2 liste: la prima contiene i fattori di caricamento su cui sono state fatte le misurazioni, la seconda il risultati di queste. I parametri hanno questi significati.
\begin{itemize}
\item \textbf{hash:} la tabella hash su cui eseguire il test.
\item \textbf{iterations:} il numero di volte che deve essere ripetuta una misurazione.
\item \textbf{interval:} la distanza tra una iterazione e l'altra.
\item \textbf{verbose:} indica se mostrare o meno lo stato attuale dei test.
\item \textbf{percent:} indica ogni quanto in percentuale aggiornare lo stato dei test.
\end{itemize}

\newlineitem{search\_experiments(m: int, m\_q: int, iter: int, interval: int, verbose: bool, type: search\_test\_type,  suffix = ""):}
Questa funzione serve per eseguire i test di un tipo particolare di ricerca su tutti i tipi i esplorazione delle tabelle hash. Questa funzione si occupa di esguire i singoli test con le funzioni precedentemente descritte, e poi salvare sui dei file opportunamente creati i risultati. I parametri hanno il seguente significato.
\begin{itemize}
\item \textbf{m:} la dimensione con cui creare le tabelle hash con esplorazione lineare ed hash doppio.
\item \textbf{m\_q:} la dimensione con cui creare le tabelle hash con esplorazione quadratica.
\item \textbf{iter:} il numero di volte che deve essere ripetuta una misurazione.
\item \textbf{interval:} la distanza tra una iterazione e l'altra.
\item \textbf{verbose:} indica se mostrare o meno lo stato attuale dei test.
\item \textbf{type:} indica il tipo di operazione di ricerca da eseguire come test.
\item \textbf{suffix:} indica il suffisso con cui verranno salvati i file dei risultati.
\end{itemize}

\newlineitem{insert\_experiments(m: int, m\_q: int, iter: int, interval: int, verbose: bool,  suffix = ""):}
Questa funzione serve per eseguire i test di inserimento su tutti i tipi i esplorazione delle tabelle hash. Questa funzione si occupa di esguire i singoli test con le funzioni precedentemente descritte, e poi salvare sui dei file opportunamente creati i risultati. I parametri hanno il seguente significato.
\begin{itemize}
\item \textbf{m:} la dimensione con cui creare le tabelle hash con esplorazione lineare ed hash doppio.
\item \textbf{m\_q:} la dimensione con cui creare le tabelle hash con esplorazione quadratica.
\item \textbf{iter:} il numero di volte che deve essere ripetuta una misurazione.
\item \textbf{interval:} la distanza tra una iterazione e l'altra.
\item \textbf{verbose:} indica se mostrare o meno lo stato attuale dei test.
\item \textbf{suffix:} indica il suffisso con cui verranno salvati i file dei risultati.
\end{itemize}
\newlineitem{load\_factor\_experiments(hash: open\_hash, a: float, iter: int, type: test\_type):}
Questa funzione esegue un test di una particolare operazione, su una tabella hash con un fattore di caricamento specifico. Questa funzione da come risultato il tempo ottenuto dalle misurazioni. I parametri hanno questi significati.
\begin{itemize}
\item \textbf{hash:} la tabella hash su cui eseguire il test.
\item \textbf{a:} il fattore di caricamento su cui eseguire il test. Sarà la funzione ad occuparsi di riempire la tabella in modo da raggiungere un fattore di caricamento il più possibile vicino a quello impostato.
\item \textbf{iter:} il numero di volte che deve essere ripetuta una misurazione.
\item \textbf{type:} il tipo di operazione di cui si vuole misurare il tempo.
\end{itemize}

\newlineitem{save\_on\_file(x, y, file\_name: str):}
Questa funzione si occupa di creare un file con il nome \textbf{file\_name} e di inserirci i valori delle liste \textbf{x} e \textbf{y}. Questo file si trova sotto la cartella \textbf{Risultati}.
\newlineitem{load\_from\_file(file\_name: str):}
Complementare alla precedente sevre per estrapolare i valori delle liste salvate nel file di nome \textbf{file\_name} creato dalla funzione \emph{save\_on\_file}. Quesat funzione parte dal presupposto che il file da leggere si trovi sollo la carteòòa \textbf{Risultati}. Ritorna 2 liste: la lista \textbf{x} e la lista \textbf{y} contenute nel file.
\newlineitem{closest\_two\_power(x: int):}
Questa funzione da come valore di ritorno la potenza esatta del 2 più vicina all'argomento \textbf{x}
\newlineitem{get\_prefix\_name(type: test\_type):}
Fornito il tipo di test da eseguire, ne ritorna il nome come stringa.
\newlineitem{get\_exploration\_name(type: hash\_type):}
Fornito il tipo di esplorazione usata, ne ritorna il nome come stringa.
\newlineitem{get\_title\_name(type: test\_type):}
Fornito il tipo di test da eseguire, ne ritorna il titolo da usare nei grafici come stringa.
\end{itemize}
\textbf{Notare bene:}tutti quei casi in cui si fa riferimento all'utilizzo del parametro iter (o iteration) le misurazioni finali ottenute sono la media di quelle eseguite \emph{iter} volte.

\subsubsection{Funzioni per Grafici}
In questo file è contenuto il codice utilizzato per la genrazione, ed eventualmente il savlataggio, dei grafici conteneti i isultati dei nostri test. \'E stato suddiviso in funzioni per una questione facilitarne la gestione.
\begin{itemize}
\newlineitem{create\_function\_plot(x, y, title: str, label: str, color: str, save: bool, file\_name: str = "", annotate: bool = True, is\_log: bool = True):}
Questa funzione serve per generare un grafico a partire dai valori dei punti da disegnare. I parametri hanno il seguente significato.
\begin{itemize}
\item \textbf{x:} il valore delle ascisse dei punti da disegnare.
\item \textbf{y:} il valore delle ordinate dei punti da disegnare.
\item \textbf{title:} il titolo da dare ap grafico.
\item \textbf{label:} l'etichetta da associare alla curva.
\item \textbf{color:} indica il colore con cui deve essere sigegnata la funzione.
\item \textbf{save:} indica se salvare o meno il grafico.
\item \textbf{annotate:} indica se annotare il valore vicino al punto con ascissa più grande.
\item \textbf{file\_name:} indica il nome con cui salvare il file.
\item \textbf{isLog:} indica se mettere la scala delle ascisse logaritmica o meno.
\end{itemize}

\newlineitem{create\_multiple\_function\_plot(x\_values, y\_values, title: str, save: bool, file\_name: str = "", is\_log: bool = True):}
Questa funzione serve per disegnare su di un grafico più funzioni differenti. I parametri hanno i segnenti significati.
\begin{itemize}
\item \textbf{x\_values:} è una lista, che contiene le liste delle ascisse delle fari funzioni.
\item \textbf{y\_values:} è una lista così definita.
\begin{enumerate}
\item Il primo elemnto di ogni lista è la lista dei valori delle ordinate dei punti.
\item Il secondo valore indica il colore con cui disegnare il grafico.
\item Il terzo valore indica l'etichetta che deve essere associata ad un particolare grafico.
\end{enumerate}
\item \textbf{title:} il titolo da dare ap grafico.
\item \textbf{save:} indica se salvare o meno il grafico.
\item \textbf{file\_name:} indica il nome con cui salvare il file.
\item \textbf{isLog:} indica se mettere la scala delle ascisse logaritmica o meno.
\end{itemize}
\newlineitem{create\_bar\_plot(x\_values, y\_values, title: str, width: float, save: bool = False, file\_name: str = "", indexes = [i/10 for i in range(10)], is\_log: bool = True):}
Questa funzione riceve in ingresso un insieme di valori che poi utilizza per creare un grafico a barre. I parametri hanno questi significati.
\begin{itemize}
\item \textbf{x\_values:} è una lista, che contiene le liste delle ascisse delle fari funzioni.
\item \textbf{y\_values:} è una lista così definita.
\begin{enumerate}
\item Il primo elemnto di ogni lista è la lista dei valori delle ordinate dei punti.
\item Il secondo valore indica il colore con cui disegnare il grafico.
\item Il terzo valore indica l'etichetta che deve essere associata ad un particolare grafico.
\end{enumerate}
\item \textbf{witdh:} la larghezza delle barre nel grafico.
\item \textbf{save:} indica se salvare o meno il grafico.
\item \textbf{file\_name:} indica il nome con cui salvare il file.
\item \textbf{indexes:} i valori dell'ascissa su cui posizionare le barre.
\item \textbf{isLog:} indica se mettere la scala delle ascisse logaritmica o meno.
\end{itemize}
\newlineitem{generate\_bar\_values(x, y):}
Questa funzione, ricevuta un lista \textbf{x} che contiene i valori delle ascisse e \textbf{y} valori delle ordinate, genera i ragguramenti utiliper generare i grafici a barre utilizzati nella relazione.
\newlineitem{setup\_plot(xlabel: str, ylabel: str, title: str, is\_log: bool = True):}
Quesat funzione serve per inizializzare un grafico con delle caratteristiche definite dai parametri che gli vengono forniti.
\begin{itemize}
\item \textbf{xlabel:} l'etichetta che indica il significato dei valori delle ascisse.
\item \textbf{ylabel:} l'etichetta che indica il significato dei valori delle ordinate.
\item \textbf{title:} il titolo del grafico.
\item \textbf{is\_log:} un valore booleano che indica se il grafico deve essere rappresentato con l'asse delle ordinate in scala logaritmica.
\end{itemize}

\newlineitem{generate\_plot(save: bool = False, file\_name: str = "Plot"):}
Questa funzione server per generare il grafico. Il parametro \textbf{save} indica se salvare o meno il grafico così generato, mentre \textbf{file\_name} serve per indicare il nome con cui savalre eventualmente il file.
\end{itemize}

\subsubsection{Altro codice}
Per quanto siano presenti altri file conteneti del codice effettivamente utilizzato, questo non viene riportato nella documentazione in quanto del tutto superfluo per la riuscita dei test.
\section{Risultati Sperimentali}

\subsection{Configurazione Preliminare}

La dimensione delle tabelle hash per gli esperimenti principali per l'esplorazione lineare e con hash doppio è di 24571. I motivi che hanno portato alla scelta di questa dimesnione sono molteplitci. Innanzo tutto è un numero primo, quindi per questi due tipi di eplorazioni ci garantisce la generazione di una permutazione degli indici della tabella, e quindi un corretta esecuzione delle operazioni richieste. Inoltre si tratta di un numero che si trova (approsimativamente) nel punto mediano tra 16384 e 32768, che sono le potenze esatte del 2 più vicine a qusto numero. Questa scelta è motivata dall'intenzione di sceglire una dimensione che si discostasse il più possibile da una potenza esatta del 2, al fine di evitare il campionamento di una porzione di bit men significativi. Infine 24571 si tratta di un numero sufficentemente grande per poter svolgere un numero di test soddisfacenti, ma anche di terminarli in un tempo contenuto date le prestazioni che l'hardware utilizzato riesce ad offrire.

Per quanto invece riguarda l'esplorazione quadratica si fornisce come dimensione della tabella la potenza esatta del 2 più vicina a 24571 (generato con la funzione \emph{closest\_two\_power}, che è 16834). Questa caratteristica non dovrebbe impattare eccessivamente sulle prestazioni di questa tabella hash, dato che i numeri inseriti sono causali (generati con la funzione \emph{random.choice} su un array di valori non ancora inseriti) e quindi non dovrebbero avere una correlazione di nessun tipo. Inoltre è possibile confrontare gli andamenti ti tabelle hash con dimensioni differenti dato che il costo delle operazioni non dipende direttamente da questo valore, ma bensì dal fattore di caricamento.

Per ottimizzare i tempi di esecuzione di questi test si è scelto di non verificare i tempi di inserimento per ogni elemento, ma di campionarli ad intervalli regolari. Questo da una parte ci permette di ridurre i tempi totali di esecuzione (e quindi potenzialmente lavorare con dimensioni delle tabelle più grandi), ma dall'altra parte rende chiaramente visibile l'andamento complessivo (a patto che l'intervallo di campionamento non sia troppo grande).

Inoltre, dato che il dispositivo non è configurato per la esclusiva esecuzione degli esperimenti, è probabile che alcuni inserimenti (senza possibilità di prevedere quali) potrebbero avere tempi di esecuzione maggiori per via dell'allocazione della CPU per compiti più prioritari. Per mitigare questo effetto ogni volta che si deve ottenere una misurazione questa viene eseguita più di una volta, per poi utilizzare la media di queste misurazione.

Dato che talvolta gli esperimenti possono richiedere diverso tempo per poter essere terminati le funzioni hanno la possibilità di scrivere sullo standard output la percentuale di quelli terminati. Questo non ha un impatto sulle misurazioni (in quanto queste considerano strettamente solo le operazioni sulla tabella hash), ma ci danno la percezione dell'effettivo avanzamento degli esperimenti.

Infine, tutti i grafici saranno presentati ponendo sull'asse delle ordinate il tempo, e su quello delle ascisse il fattore di caricamento.

\subsection{Ricerca con Successo}

Eseguendo il test di ricerca con successo con le funzioni precedentemente descritte sull'hash con esplorazione lineare si è ottenuto il seguente grafico (figura \ref{fig:Successo_Lineare_scala_lineare}).
\begin{figure}[H]
\image[0.75]{Successo_Lineare_scala_lineare}{Ricerca con sucesso (esplorazione lineare)}
\label{fig:Successo_Lineare_scala_lineare}
\end{figure}

\label{Motivazione_scala}
Come si può notare il risulta difficile apprezzare variazioni significative per fattori di caricamento di minori di 0.8. Perciò d'ora in avanti, si rappresenteranno principalemente grafici in scala logaritmica (se non specificato diversamente). 

\begin{figure}[H]
\begin{subfigure}[b]{0.5\textwidth}
\image{Successo_Lineare_scala_logaritmica}{Ricerca con successo (esplorazione lineare)}
\end{subfigure}
\begin{subfigure}[b]{0.5\textwidth}
\image{Successo_Quadratico_scala_logaritmica}{Ricerca con successo (esplorazione quadratica)}
\end{subfigure}
\begin{subfigure}[b]{0.5\textwidth}
\image{Successo_Doppio_scala_logaritmica}{Ricerca con successo (esplorazione hash doppio)}
\end{subfigure}
\begin{subfigure}[b]{0.5\textwidth}
\image{Successo_Asintotica_scala_logaritmica}{Ricerca con successo (stima asintotica)}
\end{subfigure}
\caption{Andamenti della ricerca con successo a confronto.}
\label{fig:Successo_quartetto}
\end{figure}

Come si può notare da questi 4 grafici (figura \ref{fig:Successo_quartetto}) l'andamento delle ricerche con successo hanno un andamento simile tra loro, e simile anche all'andamento della dunzione di stima asintotica. Questo però non ci permette di apprezzare le differenze relative.

\begin{figure}[H]
\image[0.75]{Successo_Confronto_Asintotico_scala_logaritmica}{Confronto tra le esplorazioni nel caso delle ricerche con successo}
\label{fig:Successo_Confronto_Asintotico_scala_logaritmica}
\end{figure} 
Da quanto si può notare dal grafico in figura \ref{fig:Successo_Confronto_Asintotico_scala_logaritmica} l'andamento relativo delle 3 esplorazioni si alterna. Possiamo infatti notare che il grafico dell'esplorazione lineare si trova al di sotto del degli altri 2 tipi di esplorazione, per poi cambiare intorno ad un fattore di caricamento di 0.8. Invece le esplorazioni quadratica e con doppio hash sembrano sovrapporsi per quasi tutto il tempo. Inoltre possiamo vedere come la funzione disegnata in nero (la funzione di stima asintotica) sia del tutto equiparabile agli andamenti attuali. Notare che il grafico di questa funzione è stato normalizzato al valore minimo ottenuto dalle altre funzioni al fine rendere più facile confrontrne gli andamenti. 

Potrebbe essere utile visualizzare l'andamento di questi tempi accorpandoli per range di fattori di caricamento. Il seguente grafico infatti presenta la media di questi valori accorpati per range di stima asintotica. In questo caso le barre che si trovano sopra l'indice $i$ indicano la media per fattori di caricamento $\alpha \in [i,\;i+0.1)$.

\begin{figure}[H]
\image[0.75]{Successo_Confronto_barre_scala_logaritmica}{Media per raggruppamento del fattore di caricamento}
\label{fig:Successo_Confronto_barre_scala_logaritmica}
\end{figure}

Il grafico di figura \ref{fig:Successo_Confronto_barre_scala_logaritmica} conferma di nuovo la conclusione che avevamo trovato prima, mettendo però in evidenza come le differenze tra esplorazione quadratica e ad hash doppio a favore di quest'ultima.

\subsubsection{Commento}
Alla luce di questi risultati possiamo dire che gli esperimenti fatti confermano i risultati teorici che volevamo verificare. Infatti possiamo notare che i grafici generati sono ragionevolmente simili alla funzione di stima asintotica, ed inoltre presentano le differenze attese.

Infatti si può notare come l'esplorazione con doppio hash fosse leggermente più efficente di quella quadratica la seconda è affetta da clustering secondario. inoltre per fattori di caricamento abbastanza alti ($\alpha > 0.8$) l'esplorazione lineare risulta peggiore delle altre. Il motivo per cui non si verifichi per valori di $\alpha < 0.7$ è da trovare nel modo con cui le funzioni hash siano implementate. Trascurando il calcolo di due moduli e le somme (le prime perchè comuni a tutte, le seconde perchè il loro impatto trascurabile), si trova che l'esplorazione lineare esegue meno istruzioni e più efficenti. Infatti per l'esplorazione linera bisogna solamente eseguire un prodotto tra interi, mentre per l'esplorazione quadratica 2 prodotti in virgola mobile (meno efficenti di quelle tra interi), e per l'hash doppio un altro modulo (ben più costoso di prodotti fra numeri).

C'è da considerare che dato le premesse teoriche era ragionevole aspettarsi una maggiore differenze tra esplorazione quadratica e con doppio hash, ma d'altra parte la teoria riguardante il clustering non forniva in nessun modo una qualche valutazione di tipo quantitativa.

\subsection{Ricerca con Insuccesso}
In questa sezione andremo ad eseminare i rsiultati riguardanti l'operazione di ricerca con insuccesso. Come già accennato nel primo paragrafo della sezione \ref{Motivazione_scala} mostreremo soltanto grafici in scala logaritmica.

Questi che seguono sono i risultati ottenuti messi a confronto.
\begin{figure}[H]
\begin{subfigure}[b]{0.5\textwidth}
\image{Insuccesso_Lineare_scala_logaritmica}{Ricerca con insuccesso (esplorazione lineare)}
\end{subfigure}
\begin{subfigure}[b]{0.5\textwidth}
\image{Insuccesso_Quadratico_scala_logaritmica}{Ricerca con insuccesso (esplorazione quadratica)}
\end{subfigure}
\begin{subfigure}[b]{0.5\textwidth}
\image{Insuccesso_Doppio_scala_logaritmica}{Ricerca con insuccesso (esplorazione con doppio hash)}
\end{subfigure}
\begin{subfigure}[b]{0.5\textwidth}
\image{Insuccesso_Asintotica_scala_logaritmica}{Ricerca con insuccesso (stima asintotica)}
\end{subfigure}
\caption{Confronto tra gli andamenti delle ricerche con insuccesso.}
\label{fig:Insuccesso_quartetto}
\end{figure}

Come mostrato in figura \ref{fig:Insuccesso_quartetto} l'andamento di queste funzioni è simile tra loro. Come fatto precedentemente mettiamole a confronto prima sovrapponendole sullo stesso grafico, e poi con la rappresentazione ragguppata.  

\begin{figure}[H]
\image[0.75]{Insuccesso_Confronto_Asintotico_scala_logaritmica}{Confronto tra andementi delle funzioni nel caso di ricerche con insuccesso}
\label{fig:Insuccesso_Confronto_Asintotico_scala_logaritmica}
\end{figure}

Il grafico rappresentato in figura \ref{fig:Insuccesso_Confronto_Asintotico_scala_logaritmica} ci mostra come le funzioni (compresa quella asintotica) seguano lo stesso andamento. Differentemente dal caso precedente si possono notare 2 effetti diversi: il primo è che la funzione con esplorazione lineare diventa meno efficente per valori più piccoli (ora per $\alpha > 0.6$), il secondo che per valori di $\alpha \longrightarrow 1$ si può notare come i valori delle esplorazioni si sovrappongano.

\begin{figure}[H]
\image[0.75]{Insuccesso_Confronto_barre_scala_logaritmica}{Media per raggruppamento dei tempi per la ricerca con insuccesso}
\label{fig:Insuccesso_Confronto_barre_scala_logaritmica}
\end{figure}

Come mostra il grafico in figura \ref{fig:Insuccesso_Confronto_barre_scala_logaritmica} questi 2 andamenti sono confermati anche nel caso di un raggruppamento per fattori di caricamento. Ancora una volta l'esplorazione con doppio hash risulta leggermente più efficente di quella quadratica.

In generale, mettendo a confronto la figura \ref{fig:Insuccesso_Confronto_barre_scala_logaritmica} (ricerca con insuccesso) e figura \ref{fig:Successo_Confronto_barre_scala_logaritmica} (ricerca con successo) il tempo assoluto richiesto per eseguire una ricerca con insuccesso è più alto.

\subsubsection{Commento}
Anche in questo caso possiamo dire di aver verificato le stime asintotiche individuate dalla teoria. Però risultano, rispetto alla ricerca con successo, nuovi fenomeni la cui spiegazione va trovata nella \emph{natura} della ricerca con insuccesso.

La ricerca con insuccesso è il caso peggiore per quanto riguarda le tabelle hash, questo perchè dovranno esplorare una sequenza di indici fintantochè non trovano una cella non allocata (indicata con \emph{NIL} nel nostro caso). Questo accentua gli effetti negativi di funzioni hash affette da clustering. E quindi giustifica perchè la velocità di ricerca dell'hash con esplorazione lineare peggiori rispetto a prima.

Invece per guistificare la "sovrapposizione" di tutti gli andamenti per gli $\alpha \longrightarrow 1$ bisogna considerare il caso specifico. Infatti quando la tabella hash è piena (per $\alpha = 1$) si ottiene che una ricerca con insuccesso degenera in una ricerca con insuccesso di una lista concatenata (dove possiamo considerare la lista come la sequenza degli elementi nelle celle generata dalla sequenza di esplorazione), e che quindi l'effetto dei clustering è del tutto irrilevante. Anzi, si ottine che, come mostrato nella figura \ref{fig:Insuccesso_Confronto_Asintotico_scala_logaritmica}, nel caso specifico $\alpha = 1$ l'esplorazione lineare torna ad essere leggermente più efficente (ricordarsi che nella figura \ref{fig:Insuccesso_Confronto_barre_scala_logaritmica} l'ultima barra è una media di ricerche per gli $\alpha \in [0.9, 1]$).

\subsection{Inserimento}
In questo paragrafo andremo a verificare i risultati sperimentali dell'inserimento. In questo caso dovremmo confrontare l'inserimento con una funzione asintotica diversa, e inoltre non esistono varianti all'inserimento. Come già detto precedentemente, per rendere più facilmente apprezzabili le variazioni dei grafici questi verranno mostrati in scala logaritmica.

\begin{figure}[H]
\begin{subfigure}[b]{0.5\textwidth}
\image{Inserimento_Lineare_scala_logaritmica}{Inserimento (esplorazione lineare)}
\end{subfigure}
\begin{subfigure}[b]{0.5\textwidth}
\image{Inserimento_Quadratico_scala_logaritmica}{Inserimento (esplorazione quadratica)}
\end{subfigure}
\begin{subfigure}[b]{0.5\textwidth}
\image{Inserimento_Doppio_scala_logaritmica}{Inserimento (esplorazione con doppio hash)}
\end{subfigure}
\begin{subfigure}[b]{0.5\textwidth}
\image{Inserimento_Asintotica_scala_logaritmica}{Inserimento (stima asintotica)}
\end{subfigure}
\caption{Confronto tra gli andamenti degli inserimenti.}
\label{fig:Inserimento_quartetto}
\end{figure}

Come mostarto dai grafici in nella figura \ref{fig:Inserimento_quartetto} possiamo vedere come le varie esplorazioni si assomiglino come andamento. In questo caso però la funzione di stima sintotica ha um andamento abbastanza diverso (lasciando perdere quelli che sono i valori assoluti. Infatti possiamo notare come le funzioni delle esplorazioni subiscano una rapida crescità per gli $\alpha \longleftrightarrow 1$, dovuti dal fattore $\frac{1}{1 - \alpha}$ che si trova dentro il logaritmo. 

\begin{figure}[H]
\image[0.75]{Inserimento_Confronto_asintotico_scala_logaritmica}{Confronto tra adamenti dell'inserimento}
\label{fig:Inserimento_Confronto_asintotico_scala_logaritmica}
\end{figure}

Invece la figura \ref{fig:Inserimento_Confronto_asintotico_scala_logaritmica} ci permette di apprezzare meglio le differenze tra le varie esplorazioni. In questo caso l'esplorazioni sebrano seguire l'andamento della stima asintotica per valori di $\alpha$ sufficientemente piccoli, per poi distaccarsi con l'avvicinarsi di 1. Bisogna comunque considereare che la stima asintotica non può essere calcolata nè in 0 nè in 1 per via del suo dominio.
Come nella ricerca con insuccesso l'eplorazione lineare diventa meno efficente per $\alpha \simeq 0.6$, per poi riallenearsi con la tabella piena.

\begin{figure}[H]
\image[0.75]{Inserimento_Confronto_barre_scala_logaritmica}{Confronto tra adamenti dell'inserimento}
\label{fig:Inserimento_Confronto_barre_scala_logaritmica}
\end{figure}

Anche il garfico a barre (figura \ref{fig:Inserimento_Confronto_barre_scala_logaritmica}) conferma gli andamenti descritti precedentemente; sia il cambio di \emph{andamento migliore} verso $\alpha > 0.6$, sia che l'andamento con hash doppio sia leggermente migliore dell'esplorazione quadratica. In questo caso la funzione di stima asintotica si discosta maggiormante, però si può ancora considerare corretto. Infatti biogno tenere in cosiderazione che la funzione di stima asintotica non tiene conto di termini di crescita di ordine inferiore.

\subsubsection{Commento}

Possiamo ancora una volta dire come gli aspetti teorici sono stati ragionevolmente verificati. Inoltre possiamo notare una certa somiglianza, sia in andamento che valori assoluti, tra i tempi dell'inserimento e quelli della ricerca con insuccesso.

\begin{figure}[H]
\begin{subfigure}[b]{0.5\textwidth}
\image{Insuccesso_Confronto_barre_scala_logaritmica}{Raggruppamento tempi di ricerca con insuccesso}
\end{subfigure}
\begin{subfigure}[b]{0.5\textwidth}
\image{Inserimento_Confronto_barre_scala_logaritmica}{Raggruppamento tempi di inserimento}
\end{subfigure}
\caption{Confronto tra ricerca con insuccesso inserimento.}
\label{fig:Confronto_ricerca_insuccesso}
\end{figure}

Come mostrano i garfici messi a confronto nella figura \ref{fig:Confronto_ricerca_insuccesso} (che sono gli stessi rispettivamente di figura \ref{fig:Insuccesso_Confronto_barre_scala_logaritmica} e \ref{fig:Inserimento_Confronto_barre_scala_logaritmica}) che i valori assoluti sono molto simili. Questo perchè i casi in entrambi i casi la sequenza di esplorazione deve essere esplorata finchè non troviamo una cella vuota prima di poter giungere al raggiungimento del risultato. Questo è perticolarmente vero poichè abbiamo supposto che non vengano eliminati nessun elemento, e che quindi non esistano celle marcate come DEL che farebbero terminare prima l'inserimento.

\subsection{Esperimenti sulla dimensione della Tabella}
Un altro esperimento che possiamo considerare significativo è quello di verificare il comportamento di una esplorazione con una tabella di dimensione diversa. In questo caso la seconda tabella sarà creata con una dimensione pari ad un numero sufficientemente vicino ad una potenza esatta del 2 (ma comunque primo).

Come riportato nella figura \ref{fig:Confronto_coefficienti} andremo ad nalizzare l'andamento di una esplorazione lineare nel caso della ricerca con insuccesso con dimensione 24571 e 16381 (dove il secondo è il numero primo più vicino alla potenza esatta del 2 \emph{16384}). Il confronto è possibile in quanto l'andamento con dipende dalla dimensione in modo diretto, ma in funzione del fattore di caricamento della tabella.

\begin{figure}[H]
\image[0.75]{Insuccesso_Confronto_Lineare_d24571_d16381_scala_logaritmica_suffisso}{Confronto tra operazioni con dimensioni della tabella diverse}
\label{fig:Confronto_dimensioni}
\end{figure}

Il risultato di figura \ref{fig:Confronto_dimensioni} mostra come gli andamenti siano del tutto sovrapponibili. L'unica differenza si può notare nel caso di $\alpha = 1$, ma come abbiamo precedentemente esposto questo è dovuta al fatto che a tabella piena la ricerca con insuccesso degenera in una lista concatenata.

\subsubsection{Commento}
Da questo esperimento si evince che nel caso di utilizzo di numeri non correlati da qualche relazione matematica l'utilizzo di una dimensione piuttosto di un'altra non comporta diferenze in termini di prestazioni (a patto che queste garantiscano la generazione di una permutazione delle celle della tabella).

\subsection{Esploraione lineare con coefficenti diversi}
Un altro test ragionevole è quello sula esplorazione lineare con coefficenti diversi da 1. In questo caso si vuole verificare se l'utilizzo di un coefficente diverso provochi un cambiamento apprezabile nella presatzione della tabella hash. Il test sarà condotto su una tabella hash con esplorazione lineare (dato che è l'unica con un grado di libertà così altro sul coefficiente da utilizzare) con coeficiente $1$ e $5$.

\begin{figure}[H]
\image[0.75]{Successo_Confronto_Lineare_c1_c5_scala_logaritmica}{Confronto di esplorazioni lineari di coefficenti diversi}
\label{fig:Confronto_coefficienti}
\end{figure}

Come riportato in figura \ref{fig:Confronto_coefficienti} possiamo notare che sostanzialemnte l'endamendo non dipende dal valore del coefficiente utilizzato. Infatti i problemi di clustering primario rimangono con qualsiasi coefficiente.

\subsection{Tempi su caso operativo}

\begin{center}
\begin{table}[H]
\begin{tabular}{c|c|c|c||c|c|c||c|c|c|}
%\hline
\cline{2-10}
& \multicolumn{3}{c||}{Successo} & \multicolumn{3}{c||}{Insuccesso} & \multicolumn{3}{c|}{Inserimento} \\
\hline
\multicolumn{1}{|l|}{$\alpha$} & Lineare & Quadratico & Doppio & Lineare & Quadratico & Doppio  & Lineare & Quadratico & Doppio \\
\hline
\multicolumn{1}{|l|}{\emph{0.0}} & 0.0029 & 0.0035 & 0.0045 & 0.0039 & 0.0045 & 0.0040 & 0.0047 & 0.0051 & 0.0054 \\
\hline
\multicolumn{1}{|l|}{0.1} & 0.0026 & 0.0029 & 0.0029 & 0.0031 & 0.0036 & 0.0034 & 0.0041 & 0.0046 & 0.0043 \\
\hline
\multicolumn{1}{|l|}{0.2} & 0.0025 & 0.0031 & 0.0031 & 0.0036 & 0.0038 & 0.0038 & 0.0045 & 0.0047 & 0.0050 \\
\hline
\multicolumn{1}{|l|}{0.3} & 0.0027 & 0.0031 & 0.0031 & 0.0039 & 0.0048 & 0.0046 & 0.0048 & 0.0055 & 0.0052 \\
\hline
\multicolumn{1}{|l|}{0.4} & 0.0029 & 0.0034 & 0.0037 & 0.0047 & 0.0051 & 0.0051 & 0.0058 & 0.0061 & 0.0059 \\
\hline
\multicolumn{1}{|l|}{0.5} & 0.0035 & 0.0037 & 0.0037 & 0.0058 & 0.0067 & 0.0062 & 0.0074 & 0.0075 & 0.0069 \\
\hline
\multicolumn{1}{|l|}{0.6} & 0.0037 & 0.0045 & 0.0043 & 0.0074 & 0.0082 & 0.0072 & 0.0092 & 0.0091 & 0.0090 \\
\hline
\multicolumn{1}{|l|}{0.7} & 0.0047 & 0.0051 & 0.0048 & 0.0132 & 0.0102 & 0.0090 & 0.0140 & 0.0131 & 0.0113 \\
\hline
\multicolumn{1}{|l|}{\textbf{0.8}} & 0.0067 & 0.0059 & 0.0053 & 0.02836 & 0.0163 & 0.0137 & 0.0307 & 0.0176 & 0.0164 \\
\hline
\multicolumn{1}{|l|}{0.9} & 0.0110 & 0.0080 & 0.0066 & 0.0887 & 0.0314 & 0.0261 & 0.1411 & 0.0352 & 0.0318 \\
\hline
\multicolumn{1}{|l|}{1.0} & 0.1080 & 0.0177 & 0.0197 & 55.21 & 43.55 & 64.76 & 32.25 & 23.75 & 36.51 \\
\hline
\end{tabular}
\caption{Tempo di esecuzione (in $ms$) di queste operazioni al variare dei fattori di caricamento.}
\label{tab:Confronto_tempi}
\end{table}
\end{center}

Come riportato dalla tabella \ref{tab:Confronto_tempi} possiamo vedere in termini di assoluti le differenze tra questi tipi di esplorazione. Innanzi tutto sono da considerarsi poco attendibili i risultati della tabella con $\alpha \simeq 0.0$, in quanto si può notare come siano leggermente maggiori dei successivi, cosa che non averebbe molto senso. Questo fenomeno può essere speigato in quanto è possibile che il computer eseguendo quel codice non sia ancora riuscito a mettere in atto tutti i processi di ottimizzazione, che possono invece essere stati attuai prima degli altri casi. Inoltre sono evidenziat i costi per $\alpha \simeq 0.8$ data l'importanza pratica che questo valore rappresenta negli utilizi pratici.

Un'altra cosa che si può notare è come in media l'esplorazione con hash doppio sia più efficiente di quella quadratica (come abbiamo già detto visto con i grafici), ma in questo caso è possibile apprezzare maggiormente questa caratteristica.

Inoltre un dato che si può evincere è che l'hash table, con qualsiasi tipo di esplorazione si utilizzi e a qualsiasi $\alpha$, privilegi nettamente le ricerche piuttosto che le altre operazioni. Mentre, per motivi difficili da capire, l'inserimento sembra essere leggermente sfavorito rispetto alla ricerca con insuccesso, tranne che per $\alpha \simeq 1.0$. 
\section{Conclusioni}
In questa sezione dicuteremo dei risultati ottenuti mediante queste sperimentazioni.

\subsection{Aderenza ai risultati teorici}
Come hanno mostrato i grafici riportati in questo relazione si può evincere senza ragionevoli dubbi che i risultati teorici siano corrispondenti alla realtà. Infatti abbiamo notato pressochè in tutti i grafici una somiglianza tra i dati ottenuti sperimentalmente e quelli teorici. Inoltre abbiamo visto come l'esplorazione lineare, data la presenza del clustering primario, risulta meno efficiente per fattori di caricamento della tabella sufficientemente grandi. Perciò possiamo dire di aver confermato le seguenti nozioni teoriche:
\begin{itemize}
\item Che l'utilizzo di una dimensione della tabella pari ad un numero primo nell'esplorazione lineare e con doppio hash garantisce la generazione di una permutazione delle celle.
\item Che è possibile utilizzare qualsiasi coefficiente per l'esplorazione lineare
\item Che il costo di una ricerca, sia con successo che insuccesso, è \bigO$(\frac{1}{1 - \alpha})$.
\item Che l'esecuzione di una ricerca con successo è in media più efficiente di una con insuccesso.
\item Che il costo di un inserimento è \bigO($\frac{1}{\alpha}log(\frac{1}{1 - \alpha})$).
\item Che l'esplorazione linerare è meno efficiente rispetto alle altre per via del clustering primario.

Detto ciò, bisogna aggiungere alcuni aspetti teorici che non erano noti all'inizio del laboratotrio, ma che sono stati chiarificati successivamente. Ovvero che per il corretto funzionamento di una tabella hash con esplorazione quadratica i coefficienti $\frac{1}{2}$ possono essere utilizzati soltanto con una dimensione della tabella che è una potenza esatta del 2.

Invece, c'è un comportamento atteso dalla teorica che non si è manifestato durante i test. Infatti essendo l'esplorazione quadratica affetta da clustering secondario ci si attendeva che fosse meno efficiente dell'esplorazione con hash doppio. Questo effetto non si è manifestato in modo significativo, oppure non è stato presente affatto. Il motivo di questo è probabilmente da trovarsi nell'insieme dei numeri che vengono inseriti. Infatti sappiamo che l'utilizzo di una dimensione pari ad una potenza esatta del 2 non crea problemi di per sé. Ma dato che queste strategie di definizione del valore hash si basano sull'utilizzo dell'operatore modulo, utilizzando una potenza esatta del 2 non si fa altro che campionare i bit meno segnificative del valore preso in esame, e quindi in contesti in cui c'è una forte correlazione tra questi numeri perde di efficienza. Esempi pratici sono delle parole in un testo o nomi di file dove è probabile che elementi molto differenti tra loro abbiano in comune la parte terminante (nel primo caso uno o più caratteri, nel scecondo l'estenzione del file). 
\end{itemize}

\subsection{Risultati pratici}
In questa sezione si andranno enunciare quelle che sono state i riscontri di carattere partico su questi test.

Una delle cose che si può notare è sicuramente come i tempi di escuzione delle operazioni nella tabella hash, per $\alpha < 0.8$ risultino molto bassi se messi a confronto con i valori valori di $\alpha$ maggiori. Questo ci porta alla conclusione che l'indicazione pratica dell'utilizzo di tabelle hash con $\alpha \simeq 0.8$ sia corretta. Infatti questo valore garantisce ancora dei tempi di escuzione ragionevolemente bassi, e d'altra parte riduce lo spreco della memoria in quanto vengono lascate vuoto "solo" il 20\% delle celle, e quindi solo 1 byte su 5 viene sprecato in memoria.

In conclusione finale non si può dire che questa struttura dati si avvicina alla suo corrispondente teorico, ovvero dotato di tempi di esecuzione costanti in qualsiasi condizione, ma resta una struttura dati adeguata in quei casi in cui di deve ottenere un buon compromesso tra l'utilizzo della memoria e i tempi di accesso hai dati.

\newpage

\listoffigures
\listoftables
\end{document}
